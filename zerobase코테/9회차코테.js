// 문제 01
// 무인도에 갇힌 N명의 인원이 우연히 발견한 보트를 통해 탈출을 생각하고 있습니다.
// 보트의 경우 2인승이라 한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한이 있습니다.
// 사람들의 몸무게를 담은 배열과 보트 무게제한 limit를 주어줄 때
// 최대한 적게 보트를 사용하여 모든 사람을 구출 하려고 할 때 보트의 사용 횟수를 구하는 함수를 작성하세요.
// 단, 무인도에 갇힌 사람은 1명 이상이며, 보트의 무게 제한보다 사람의 몸무게보다 큰 경우는 없습니다.

// 입력
// 사람들의 몸무게를 담은 배열 A, 보트의 제한 무게 K

// 출력
// 최소한의 보트 사용 횟수

// 핵심 아이디어
// 그리디 알고리즘
// 몸무게가 가장 가벼운 사람과 가장 무거운 사람을 묶어서 보트에 태우는 것이 최적
// 가장 가벼운 사람과 가장 무거운 사람을 한 쌍으로 묶어 보트에 태우기

// 풀이
function solution(arr, k) {
  let answer = 0;
  arr.sort((a, b) => a - b);
  let left = 0; // 가장 가벼운 사람의 인덱스
  let right = arr.length - 1; // 가장 무거운 사람의 인덱스
  while (left <= right) {
    if (arr[left] + arr[right] <= k) {
      left++;
      right--;
    } else {
      // 보트의 무게 제한을 초과하는 경우
      right--;
      // 가장 무거운 사람만 태우고 다음 보트에 태우기 위해 오른쪽 인덱스 감소
    }
    answer++; // 보트 사용 횟수 증가
  }
  return answer;
}

let arr = [45, 55, 78, 88, 65, 77, 58];
let k = 200;
console.log(solution(arr, k));

// 문제 02
// 0 ~ 100까지의 숫자가 적혀있는 카드가 있습니다.
// 해당 카드를 뽑은 순서에 따라 아래 규칙에 의거해 점수를 책정합니다.
// 1. 뽑은 카드의 숫자와 현재 까지 뽑은 카드의 수를 곱한다.
// 2. 짝수번째로 뽑은 카드의 경우 -1을 더 곱한다.
// 배열 A에 뽑은 카드의 리스트가 제공될때 해당 카드들이 규칙에 따라 나올수 있는 가장 큰 점수가 몇점인지 구하는 함수를 작성하세요.

// 입력
// 카드 리스트 배열 A

// 출력
// 규칙에 의거해서 나올수 있는 최대 점수

// 핵심 아이디어
// 그리디 알고리즘
// 카드를 내림차순으로 정렬
// 짝수번째와 홀수번째에 따라 각각 다른 계산을 수행하여 최대 점수를 찾아내기

// 풀이
function solution(cards) {
  let answer = 0;
  cards.sort((a, b) => b - a); // 카드를 내림차순으로 정렬

  for (let i = 0; i < cards.length; i++) {
    if (i % 2 === 0) {
      // 짝수번째 카드인 경우
      answer += cards[i] * (i + 1); // 현재까지 뽑은 카드의 수를 곱해서 더함
    } else {
      // 홀수번째 카드인 경우
      answer -= cards[i] * (i + 1); // 현재까지 뽑은 카드의 수를 곱해서 뺌
    }
  }
  return answer;
}

// 예시
let cardList = [5, 2, 8, 3, 1];
console.log(maxScore(cardList)); // 출력: 45

// 문제 03
// 우리나라의 화폐단위는 50000, 10000, 5000, 1000, 500, 100, 50, 10, 5, 1 원으로 이루어져 있습니다.
// 거스름돈 금액 A원이 입력 되었을때 해당 거스름돈을 만족하는 최소한의 화폐 개수를 리턴하는 함수를 작성하세요.

// 입력
// 거스름돈 금액 A

// 출력
// 최소한의 화폐 개수

// 핵심 아이디어
// 그리디 알고리즘
// 거스름돈으로 사용될 화폐의 단위를 내림차순으로 순회
// 각 화폐 단위로 최대한 많이 사용하여 거스름돈을 만들도록

// 풀이
function solution(a) {
  let answer = 0;
  const denominations = [50000, 10000, 5000, 1000, 500, 100, 50, 10, 5, 1];
  for (let i = 0; i < denominations.length; i++) {
    let coin = denominations[i];
    answer += Math.floor(a / coin);
    // 해당 화폐 단위로 최대한 사용할 수 있는 개수를 더함
    a %= coin;
    // 해당 화폐로 거스름돈을 만든 후 남은 금액을 다시 계산
  }
  return answer;
}

// 예시
let changeAmount = 17620;
console.log(minChangeCoins(changeAmount)); // 출력: 7

// 문제 04
// 낱말 퍼즐을 풀려고 합니다. 퍼즐 판은 4 x 4 크기로 임의의 한글이 섞여 있습니다.
// 주어진 낱말이 퍼즐 판에 인접한 형태로 존재하는지 구하는 함수, solution을 완성해주세요.

// 예를 들어, puzzle [[`대`, `한`, `가`, `나`], [`국`, `민`, `다`, `라`], [`마`, `바`, `사`, `아`], [`자`, `차`, `카`, `타`]] 과 word `대한민국`이 있을 때,
// > puzzle[0][0] = `대`
// > puzzle[0][1] = `한`
// > puzzle[1][1] = `민`
// > puzzle[1][0] = `국`
// 으로 결과는 true입니다.

// 제한 사항
// 모든 낱말은 한글입니다.
// 인접함은 상하좌우로 붙어있는 단어를 말합니다.
// word는 공백없는 문자열입니다.
// 한번 사용된 퍼즐 판의 낱말은 또다시 사용할 수 없습니다.

// 입력 형식
// puzzle은 4 * 4 크기의 배열입니다.
// word는 길이가 1 이상 10 이하의 문자열입니다.

// 출력
// 주어진 낱말이 퍼즐 판에 인접한 형태로 존재하는지를 출력합니다.

// 핵심 아이디어
// dfs 깊이 우선 탐색

// 문제 05
// 3 x 3개의 격자 형태의 두더지 게임판이 있습니다. 두더지들은 들어가거나 나와 있는데, 이 두더지들을 모두 나오도록 바꾸는 게임입니다.
// 두더지를 조작하는 유일한 방법은 10개의 스위치를 조작하는 것으로, 각 스위치는 1개 이상의 두더지에 연결되어 있습니다.
// 한 스위치를 누를 때마다, 해당 스위치와 연결된 나와 있던 두더지는 들어가고, 들어가 있던 두더지는 나옵니다.
// 이때, 모든 두더지를 나오게 하려면 최소한 스위치를 몇 번이나 눌러야 할지를 출력하는 함수, solution을 완성해주세요.

// 예를 들어, 게임판의 9마리 두더지 상태 state로 [ 1, 0, 1, 0, 0, 1, 1, 1, 1 ]가 있고,
// 10개의 스위치에 연결된 두더지 번호 linkNums가[[1], [7], [8], [4, 7], [1, 3], [3, 4, 8], [0], [6], [2], [1, 4]] 라고 가정할 때,
// 스위치에 연결된 두더지 정보는 다음과 같습니다.
// > 스위치 0에 연결된 두더지 번호 1
// > 스위치 1에 연결된 두더지 번호 7
// > 스위치 2에 연결된 두더지 번호 8
// > 스위치 3에 연결된 두더지 번호 4, 7
// > 스위치 4에 연결된 두더지 번호 1, 3
// > 스위치 5에 연결된 두더지 번호 3, 4, 8
// > 스위치 6에 연결된 두더지 번호 0
// > 스위치 7에 연결된 두더지 번호 6
// > 스위치 8에 연결된 두더지 번호 2
// > 스위치 9에 연결된 두더지 번호 1, 4
// 이때, 모든 두더지를 나오게 하려면 최소한 3번의 스위치(스위치 0, 2, 5)를 눌러야 합니다.

// 제한 사항
// 두더지의 상태는 0이면 들어가 있는 두더지, 1이면 나와 있는 두더지입니다.

//입력 형식
// 두더지 상태 state가 주어집니다.
// state는 0과 1로 이루어진 길이가 9인 배열입니다.
// 스위치에 연결된 두더지 번호 linkNums가 주어집니다.
// linkNums는 각 스위치에 연결된 두더지 번호로 이루어진 길이가 10인 배열입니다.

// 출력 형식
// 모든 두더지를 나오게 하도록 스위치를 눌러야 하는 최소한의 수를 출력합니다.
// 모든 두더지를 나오게 할 수 없으면 -1을 출력합니다.

// 핵심 아이디어
// 완전 탐색
// 모든 스위치의 가능한 조합을 확인하고 각 조합에 대해 두더지의 상태를 업데이트
// 모든 두더지가 나와 있는지 확인...?

// 그래프
