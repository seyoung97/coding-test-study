// 문제 01
// 정수가 들어있는 배열 A가 주어질 때 연속 합이 가장 큰 수열의 합을 반환하는 함수를 작성하세요.
// 만약 가장큰 합이 음수인 경우에는 0으로 반환하세요.
// 예를들어 배열 A에 [2, -8, 3, -2, 4, -10] 이 들어있는 경우
// 3 - 2 4 를 선택했을 때 값이 5로 가장 큰 값이 나온다.

// 입력
// 정수들이 들어있는 배열 A

// 출력
// 가장 큰 연속합 또는 0

// 핵심 아이디어
// 동적 계획법
// 배열을 순회하면서 현재까지의 부분합 currentSum과 최대 부분합 maxSum을 업데이트

// 풀이
function solution(arr) {
  let answer = 0;
  let maxSum = arr[0];
  let currentSum = arr[0];
  for (let i = 0; i < arr.length; i++) {
    currentSum = Math.max(arr[i], currentSum + arr[i]);
    maxSum = Math.max(maxSum, currentSum);
  }
  return (answer = maxSum > 0 ? maxSum : 0);
}

let arr = [2, -8, 3, -2, 4, -10];

// 문제 02
//  h x w개의 격자 형태의 게임판이 있습니다. 이 중 왼쪽 위에 시작점이 있고, 오른쪽 아래에 종료 지점이 있습니다.
// 게임 방법은 시작 지점에 말을 놓고, 말을 종료 지점까지 이동하면 이기는 게임이며, 말은 오른쪽이나 아래로만 이동할 수 있습니다.
// 이때, 게임을 이기는 방법의 수를 출력하는 함수, solution을 완성해주세요.

// 예를 들어, h가 2이고, w가 3인 게임판이 주어질 때, 게임을 이기는 방법의 수는 다음과 같이 총 3가지 방법이 있습니다.
// > 오른쪽 -> 오른쪽 -> 아래
// > 오른쪽 -> 아래 -> 오른쪽
// > 아래 -> 오른쪽 -> 오른쪽

// [제한 사항]
// - 말은 오른쪽이나 아래로만 이동할 수 있습니다.

// [입력 형식]
// - 두 정수 h와 w는 1 이상 25 이하의 정수입니다.

// [출력 형식]
// - 게임을 이기는 방법의 수를 출력합니다.

// 핵심 아이디어
// 동적계획

// 풀이
function solution(h, w) {
  // dp 배열 초기화
  const dp = [];
  for (let i = 0; i < h; i++) {
    dp.push(Array(w).fill(0));
  }

  // 시작 지점은 1가지 방법으로 도달 가능
  dp[0][0] = 1;

  // dp 배열 채우기
  for (let i = 0; i < h; i++) {
    for (let j = 0; j < w; j++) {
      // 오른쪽으로 이동하는 경우
      if (j + 1 < w) {
        dp[i][j + 1] += dp[i][j];
      }
      // 아래로 이동하는 경우
      if (i + 1 < h) {
        dp[i + 1][j] += dp[i][j];
      }
    }
  }

  // 종료 지점까지 도달하는 경우의 수 반환
  return dp[h - 1][w - 1];
}

// 예제 h=2, w=3에 대한 호출
const result = solution(2, 3);
console.log(result); // 출력 결과: 3

// 문제 03
//  길 위에 사과나무와 오렌지 나무가 있습니다.
// 사과 열매 하나당 1점, 오렌지 열매 하나당 - 1점이라고 할 때, 길 위의 연속으로 이어진 나무에서 얻을 수 있는 최고 점수를 구하는 함수, solution을 완성해주세요.
// 예를 들어, 길 위에 있는 나무의 열매 중 사과 열매의 수는 양수로, 오렌지 열매 수는 음수로 표현된 fruits [-2, 5, -3, 6, 8, -1, -5, 3]가 있을 때
// 얻을 수 있는 최고 점수는 2번째부터 5번째까지 수확했을 때 점수인 16점(5 - 3 + 6 + 8) 입니다.

// 제한 사항
//  - 열매 수확은 띄엄띄엄할 수 없으며, 연속된 나무의 모든 열매를 수확해야 합니다.
//  - 사과 열매 하나는 1점, 오렌지 열매 하나는 -1점입니다.
//  - 최소한 하나의 나무의 열매는 수확해야 합니다.

// 입력 형식
//  - 길 위에 과일의 점수를 나타낸 fruits가 주어집니다.
//  - fruits는 -1000 이상 1000 이하의 정수로 이루어진 배열입니다.
//  - 길 위의 나무의 수는 1개 이상 10,000개 이하입니다.

// 출력 형식
//  - 길 위의 연속으로 이어진 나무에서 얻을 수 있는 최고 점수를 출력합니다.

// 핵심 아이디어
// 동적 계획법

// 풀이
function solution(fruits) {
  if (fruits.length === 0) {
    return 0;
  }

  let maxSum = fruits[0];
  let currentSum = fruits[0];

  for (let i = 1; i < fruits.length; i++) {
    currentSum = Math.max(fruits[i], currentSum + fruits[i]);
    maxSum = Math.max(maxSum, currentSum);
  }

  return maxSum;
}

let fruits = [-2, 5, -3, 6, 8, -1, -5, 3];
console.log(solution(fruits));

// 문제 04
// 당신은 수직선 위에 서있습니다.
// 그리고 당신은 같은 수직선 위의 n미터 떨어진 목적지로 가려고 합니다.
// 당신은 한번에 수직선 위를 k 이하의 정수 거리만큼 이동할 수 있으며, 처음 이동한 방향으로만 계속 이동할 수 있습니다.
// 그리고 직전에 이동한 거리와 같은 거리만큼 다시 이동할 수는 없습니다.
// 예를 들어, 3-2-3 순서대로 이동했다면 다음에 3만큼 이동할 수 없습니다.
// 수직선 길이 n과 이동 가능한 최대 거리 k가 주어질 때, 목적지에 도착 가능한 경로의 경우의 수를 출력하는 함수, solution을 완성해주세요.
// 결과 값이 매우 클 수 있으니, 1,000,000,007로 나눈 나머지 값을 구해주세요.

// 입력 형식
// - n은 1 이상 1,000 이하의 정수입니다.
// - k는 1 이상 100 이하의 정수입니다.

// 출력 형식
// - 목적지로 도착 가능한 경로의 경우의 수를 1,000,000,007로 나눈 나머지 값을 출력합니다.

// 핵심 아이디어
// 동적 계획

// 풀이
function solution(n, k) {
  const MOD = 1000000007;

  // dp 배열 초기화
  const dp = Array(n + 1).fill(0);
  dp[0] = 1;

  // 이동 가능한 최대 거리까지 경우의 수를 누적하여 저장
  for (let i = 1; i <= k; i++) {
    for (let j = i; j <= n; j++) {
      dp[j] = (dp[j] + dp[j - i]) % MOD;
    }
  }

  // 목적지에 도착 가능한 경우의 수 반환
  return dp[n];
}

console.log(solution(5, 3));

// 문제 05
// n 층의 피라미드의 꼭대기에서 1층으로 내려와 탈출하려고 합니다.
// 피라미드에는 방이 있으며, n 층에는 1개의 방이 존재하고, n - 1 층에는 2개의 방, n - 2 층에는 3개의 방, 1층에는 n개의 방이 존재합니다.
// 각 방은 왼쪽 아래와 오른쪽 아래의 방으로 이동하는 계단이 있고, 각 방에는 j개의 보석이 존재합니다.
// n 층의 피라미드 각 방에 존재하는 보석의 정보 arr가 주어질 때, 꼭대기 층에서 1층까지 내려오면서 모을 수 있는 보석의 최대 수를 구하는 함수, solution을 완성해주세요.

// 예를 들어, 3층의 피라미드 그림 (a) 인 각 방에 존재하는 보석의 정보 arr가 [ [3], [5, 10], [4, 8, 6] ]이 주어질 때,
// 피라미드를 탈출하며 모들 수 있는 보석의 최대 수는 그림(b) 인 다음과 같습니다.
// 3 + 10 + 8 = 21

// 제한 사항
// - 계단은 올라갈 수 없고, 내려갈 수만 있습니다.

// 입력 형식
// - 피라미드의 층수 n은 1 이상 100 이하의 정수입니다.
// - 각 방의 보석 수 j는 1 이상 1000 이하의 정수입니다.

// 출력 형식
// - 피라미드를 탈출하며 모을 수 있는 보석의 최대 수를 출력합니다.

// 핵심 아이디어
// 동적 계획법

function solution(pyramid) {
  const n = pyramid.length;

  // dp 배열 초기화
  const dp = [];
  for (let i = 0; i < n; i++) {
    dp.push(Array(i + 1).fill(0));
  }

  // 꼭대기 층 초기화
  dp[0][0] = pyramid[0][0];

  // 각 층에서의 최대 보석 수 계산
  for (let i = 1; i < n; i++) {
    for (let j = 0; j <= i; j++) {
      // 왼쪽에서 내려오는 경우
      dp[i][j] = pyramid[i][j] + (j > 0 ? dp[i - 1][j - 1] : 0);
      // 오른쪽에서 내려오는 경우
      dp[i][j] = Math.max(dp[i][j], pyramid[i][j] + (j < i ? dp[i - 1][j] : 0));
    }
  }

  // 꼭대기 층에서 내려오면서 모을 수 있는 보석의 최대 수 찾기
  let maxGems = 0;
  for (let j = 0; j < n; j++) {
    maxGems = Math.max(maxGems, dp[n - 1][j]);
  }

  return maxGems;
}

let pyramid = [[3], [5, 10], [4, 8, 6]];
console.log(solution(pyramid));
